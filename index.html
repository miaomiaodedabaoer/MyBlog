<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Mmddb</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Mmddb">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mmddb">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Zhang Penghe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mmddb" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mmddb</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-DAG 检测" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/05/DAG%20%E6%A3%80%E6%B5%8B/" class="article-date">
  <time datetime="2021-10-05T07:09:21.513Z" itemprop="datePublished">2021-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/05/DAG%20%E6%A3%80%E6%B5%8B/">DAG 检测</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>DAG（Directed acyclic graph）就是有向无环图。在无向图的基础上，<strong>任何顶点</strong>都无法经过若干条边<strong>回到该点</strong>，则这个图就没有环路，称为有向无环图。有向无环图的<a href="https://zh.wikipedia.org/wiki/拓扑排序" target="_blank" rel="noopener">拓扑排序</a>为所有边的起点都出现在其终点之前的排序。我们可以用 BFS 来求一个图的拓扑排序，借用 leetcodes上课程表 <a href="https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/" target="_blank" rel="noopener">题解</a> 的说法。代码以及注释如下，comment掉的是记录一个拓扑排序的代码。</p>
<blockquote>
<p>我们考虑拓扑排序中最前面的节点，该节点一定不会有任何 <strong>入边</strong>，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以<strong>移除它的所有出边</strong>，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p>
</blockquote>
<img src="../images/DAG.png" alt="DAG" style="zoom:15%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">// 邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];       <span class="comment">// 入度表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            adj.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] req : prerequisites)&#123;   <span class="comment">// 填充两个表</span></span><br><span class="line">            indegree[req[<span class="number">0</span>]]++;</span><br><span class="line">            adj.get(req[<span class="number">1</span>]).add(req[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;  <span class="comment">// 先把入度为 0 的加进去</span></span><br><span class="line">                q.offer(i);</span><br><span class="line">                <span class="comment">// path.add(i)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> pre = q.poll(); <span class="comment">// 取出一个入度为 0 的</span></span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.get(pre).size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> next = adj.get(pre).get(i); <span class="comment">// 移除所有出边</span></span><br><span class="line">                indegree[next]--;    <span class="comment">// 也就是他们的入度 -1</span></span><br><span class="line">                <span class="keyword">if</span>(indegree[next] == <span class="number">0</span>)&#123; <span class="comment">// 如果相邻的变为 0， 放入队列</span></span><br><span class="line">                    q.offer(next);</span><br><span class="line">                    <span class="comment">// path.add(next);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/10/05/DAG%20%E6%A3%80%E6%B5%8B/" data-id="ckudrdrr40000rl9kdelxevgl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HSBC job simulation test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/30/HSBC%20job%20simulation%20test/" class="article-date">
  <time datetime="2021-09-30T01:22:12.194Z" itemprop="datePublished">2021-09-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/30/HSBC%20job%20simulation%20test/">HSBC job simulation test</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p><strong>Everyone needs</strong> to <strong>be aware of</strong> what XXX <strong>ahead of</strong> </p>
<p>in which this project was discussed <strong>alongside</strong> (and) what actions need to be done.</p>
<h3 id="想办法"><a href="#想办法" class="headerlink" title="想办法"></a>想办法</h3><p><strong>think of ways to involve everyone</strong>  </p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>outlining</strong> the discussions</p>
<h3 id="跟进电话"><a href="#跟进电话" class="headerlink" title="跟进电话"></a>跟进电话</h3><p><strong>schedule follow-up call</strong></p>
<h3 id="国际化团队"><a href="#国际化团队" class="headerlink" title="国际化团队"></a>国际化团队</h3><p><strong>Considering</strong> the project needs to <strong>work globally</strong>, an international team is needed to ensure success. As a result, the team <strong>operates acrosss different time zones</strong>, which makes <strong>team conference calls</strong> and daily communication <strong>difficult to schedule and run</strong>.</p>
<p>As we work on different projects on XX, you will need to <strong>collaborate with colleagues from different areas of the bank.</strong> </p>
<p><strong>geographically distributed project team</strong> </p>
<h3 id="区域性-realease"><a href="#区域性-realease" class="headerlink" title="区域性 realease"></a>区域性 realease</h3><p>When <strong>realeasing</strong> new technologies or processes <strong>regionally</strong>, <strong>work must be done</strong> to understand all <strong>local rules and regulations.</strong> This will <strong>determine</strong> <strong>how the project will progress</strong> and the work <strong>is typically done before</strong> <strong>other activities start</strong>. </p>
<h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3><p><strong>what the likelihood</strong> (可能性) of the risks are</p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p><strong>I appreciate the importance of</strong> ??</p>
<p><strong>After consideration</strong>, So <strong>I recommend that</strong> the initial research is done first, <strong>even if this means</strong> <strong>longer timelines</strong>. </p>
<p><strong>Although the situation is not ideal</strong></p>
<p><strong>Following the right process</strong> is always <strong><em>at the forefront</em> of our mind.</strong></p>
<h4 id="Your-greatest-strength"><a href="#Your-greatest-strength" class="headerlink" title="Your greatest strength"></a>Your greatest strength</h4><p>My greatest strength is my adaptability and self-study ability, I can fit in the new environment and learn new things quickly.<br> At HSBC, we are working in a global environment, with a distributed and international team, where people work across different time zones. I think you need to have the ability adjust yourself and cooperate with you foreign colleagues, respect their culture and working habit, understand things in their way. So probably you need to learn a lot of new things in a short time.</p>
<h4 id="How-to-implement-AI-to-our-bank-app"><a href="#How-to-implement-AI-to-our-bank-app" class="headerlink" title="How to implement AI to our bank app?"></a>How to implement AI to our bank app?</h4><p>The 3 Technology all have palaces to use.</p>
<p>First is the chatbot, it can be used to solve user’s common problems, accept questions, extract keywords and give a series of answers. If it <strong>encounter</strong> <strong>unrecognizable problems</strong>, people will be transferred to professional customer service. Secondly, through the collection of a large number of questions, we can also analyze and improve our app UI or update more features. Second is <strong>customer profiling</strong> , I think we can implement it to our app in three steps, firstly, we can collect the user’s personal information, such as their shopping habits, family, occupation; In the second step, we can use our algorithms and computing resources to analyze the relationship of these data. The last step, we use these discoveries to predict the products that users are most likely to buy, then give recommendations. The last tech is Vitrual assistant. I believe it is a more advanced AI application, which can include the two technologies we said before and other advanced technologies. Due to time constraints, we will leave it to the next time</p>
<h4 id="The-benefits-limitiaion-and-risk-of-AI"><a href="#The-benefits-limitiaion-and-risk-of-AI" class="headerlink" title="The benefits, limitiaion and risk of AI"></a>The benefits, limitiaion and risk of AI</h4><p>In my opinion, the key advantage of AI <strong>lies in</strong> its ability to <strong>analyze large-scale data</strong> and <strong>find  the relationship between things</strong>. First, we collect a large amount of information, then use algorithms to analyze, and finally we make prediction about future events based on the discoveries, which will help us make wiseable decisions  and benefit the society. Regrads to its limitations, <strong>what I can think of</strong> is that AI relies too much on data, and it always start from collecting work. As <strong>people’s awareness of privacy</strong> increases, fewer people are willing to share their sensitive information to company, so it may be more difficult to apply AI in business. Speaking of risk, the first point is <strong>that if we have the right to collect and use user’s data</strong>. We must ensure that we have got <strong>the user’s consent</strong> before collecting work and we must let them know the purpose of the data. The second pint is <strong>ethical problems</strong>, whether the AI is harmful to society or certain groups of people and animals. And whether the work we do <strong>complies with</strong> the local rules and regulations. We must research these risks, which will determine how the project will progress and it typically done before other activities start. </p>
<h4 id="How-to-respond-colleagues-who-feel-depressed-about-the-delay-of-new-features"><a href="#How-to-respond-colleagues-who-feel-depressed-about-the-delay-of-new-features" class="headerlink" title="How to respond colleagues who feel depressed about the delay of new features"></a>How to respond colleagues who feel depressed about the delay of new features</h4><p>Hi Jamel, I fully understand your depression about our app’s delay, and I believe everyone in the company does not want to see this situation. <strong>I appreciate the importance of</strong> launching the app on time. But as I found some problems in the application, if we leave it alone, there may be some potential risks after we launch the app. Firstly, the problems will make our website running at risk and make strange things happen during normal requests by the user. It will bring bad experience to our customers. Secondly, the problem may be used by some bad guys to attack our system, it may break down our website, make the database exposed to the outside world. So our user’s valuable data will be unsecured. Thirdly, an APP with some flaws may leave a bad image in people’s mind, it will damage our company’s reputation and bring unnecessary burden to Public Relationship Department. Moreover, these are just some points that I can think of in 3 mins.  <strong>After consideration, I recommend that</strong> we update the new features / fix the problem as soon as possible and then launch the app, even it means a longer timeline. I will try my best to make it as soon as possible. Your understanding will be appreciated.</p>
<h4 id="The-most-exciting-AI-tech"><a href="#The-most-exciting-AI-tech" class="headerlink" title="The most exciting AI tech"></a>The most exciting AI tech</h4><p>I’d like to share with you something about the <strong>customer profiling</strong>, which is the best AI technology that comes to my mind. The typical work process of PR is that first, it collects user’s data, including their details, shopping habit, etc, then use the algorithm to classify user and discover the relationship between things, then use these discoveries to predict the user behaviour and make recommendations. For example, there hava a research has shown the relationship  between beer and diapers, so maybe we can get similar founding if we used it in our app. Likem Maybe we can find the relationships between users’ specific characters and our banking products. With that, we can show more similar choices for the user, they might be very interested in that, or that is exactly what people want to buy.<br>Also, if we can find the frequency or the consumption rate of some product, we can give people the product’s link and notify the user.<br>So, the Customer Profiling has a chance to become the guy who knows the user best. I think PR will excitingly benefit our customers.</p>
<h4 id="Delay-features"><a href="#Delay-features" class="headerlink" title="Delay features"></a>Delay features</h4><p>Dear Sir,</p>
<p>Hi Jamel, I fully understand your depression about the delay of AI featrue, and I believe everyone in the company does not want to see this situation. <strong>I appreciate the importance of</strong> add AI features and we ensure it will make app better.</p>
<p>But I’d like to show you some reasons about why we should develop the features Already determined. Firstly, development work of current features is just in the key time, we have put a lot of human recourse and money on that, if we add the new feature now, our schedule will be interrupted and we can not ensure to make all features perfectly. Secondly, the new features mean a longer timeline, and we have announced our release date to the outside world. If we delay it now, it may make trouble to the department of Public Relation and damage our company reputation.<br>Thirdly, the features you proposed are not the necessary and the most important process in our app, so we can merge them into our second iteration version or the third iteration version. So, after consideration, I recommend that we do not develop the feature now and leave it to version 1.1 or 1.2. Your understanding will be appreciated.</p>
<p>You sincerely,<br>Jon</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/09/30/HSBC%20job%20simulation%20test/" data-id="ckuayh1a50000rc9k0s6d4nwy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DISTINCT &amp; GROUP BY" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/25/DISTINCT%20&%20GROUP%20BY/" class="article-date">
  <time datetime="2021-09-25T06:36:09.717Z" itemprop="datePublished">2021-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/25/DISTINCT%20&%20GROUP%20BY/">DISTINCT &amp; GROUP BY</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>假设我们现在有 students 表如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">students-</span><br><span class="line">+<span class="comment">------+---------+</span></span><br><span class="line">| id   |  name   |</span><br><span class="line">+<span class="comment">------+---------+</span></span><br><span class="line">| 1    |  Disha  |</span><br><span class="line">| 2    |  Albert |</span><br><span class="line">| 3    |  Disha  |</span><br><span class="line">| 4    |  David  |</span><br><span class="line">| 5    |  Andrew |</span><br><span class="line">| 6    |  Rohit  |</span><br><span class="line">| 7    |  Albert |</span><br><span class="line">+<span class="comment">------+---------+</span></span><br></pre></td></tr></table></figure>

<p>当我们想获取表中 unique 的记录的话，使用 distinct时，如果只 select name 的话，没有任何问题，可以得到正确的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select distinct name from students;</span><br><span class="line">+---------+</span><br><span class="line">|  name   |</span><br><span class="line">+---------+</span><br><span class="line">|  Disha  |</span><br><span class="line">|  Albert |</span><br><span class="line">|  David  |</span><br><span class="line">|  Andrew |</span><br><span class="line">|  Rohit  |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>

<p>但是如果还想 select id 呢，这时候就出现了问题，名字相同，但是 id不同的 record被保留了，如 Disha 和 Albert，虽然我们在 name 前加了 distinct。这是因为 mysql 在判断记录是否 unique时，会把 （name，id）组合作为依据，在判断时，如果两个组合只是名字相同，id不同，则会被认为是不重复的 record，也就会留下他们两个。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select distinct name, id from students;</span><br><span class="line">+<span class="comment">--------+-----+</span></span><br><span class="line">| name   | id  |</span><br><span class="line">+<span class="comment">--------+-----+</span></span><br><span class="line">| Disha  |  1  |  &lt;-</span><br><span class="line">| Albert |  2  |   &lt;-</span><br><span class="line">| Disha  |  3  |  &lt;- </span><br><span class="line">| David  |  4  |</span><br><span class="line">| Andrew |  5  |  </span><br><span class="line">| Rohit  |  6  |</span><br><span class="line">| Albert |  7  |   &lt;-</span><br><span class="line">+<span class="comment">--------+-----+</span></span><br></pre></td></tr></table></figure>

<p>当我们使用 group by 时，便可以得到正确的结果，此时相同名字的记录，只显示第一个出现的，也就是 （1， Disha）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id, name from students group by name;</span><br><span class="line">+<span class="comment">------+---------+</span></span><br><span class="line">| id   |  name   |</span><br><span class="line">+<span class="comment">------+---------+</span></span><br><span class="line">| 1    |  Disha  |</span><br><span class="line">| 2    |  Albert |</span><br><span class="line">| 4    |  David  |</span><br><span class="line">| 5    |  Andrew |</span><br><span class="line">| 6    |  Rohit  |</span><br><span class="line">+<span class="comment">------+---------+</span></span><br></pre></td></tr></table></figure>

<p>如果我们把 id 也加入到 group by 的条件中呢，，此时会得到我们最开始用 distinct 产生的结果。但是 group by 更多的运用于分组查询，选出 unique 的记录并不是其主要用途。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id, name from students group by id, name;</span><br><span class="line">+<span class="comment">------+---------+</span></span><br><span class="line">| id   |  name   |</span><br><span class="line">+<span class="comment">------+---------+</span></span><br><span class="line">| 1    |  Disha  |</span><br><span class="line">| 2    |  Albert |</span><br><span class="line">| 3    |  Disha  |</span><br><span class="line">| 4    |  David  |</span><br><span class="line">| 5    |  Andrew |</span><br><span class="line">| 6    |  Rohit  |</span><br><span class="line">| 7    |  Albert |</span><br><span class="line">+<span class="comment">------+---------+</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/09/25/DISTINCT%20&%20GROUP%20BY/" data-id="cktzlg7c60000fo9k9glad6ux" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-交换类排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/18/%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F/" class="article-date">
  <time datetime="2021-09-18T12:19:48.393Z" itemprop="datePublished">2021-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/18/%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F/">交换类排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这种类型主要靠元素之间的交换来完成排序，常见的交换类排序主要是冒泡排序，和快速排序。</p>
<p>冒泡排序：一次次的遍历带排序的范围，比较两个元素，按照顺序交换他们的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 随着 i 的增加，比较的范围越来越小，从 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加入在一轮遍历后，发现没有需要改变顺序的相邻元素，也就是说排好序了已经，上面的算法还会继续比较下去。为了避免时间浪费，可以把是否调换顺序用一个变量记录，如果值为0，就说明已经排好了</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> change;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            change = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j + <span class="number">1</span>])&#123;</span><br><span class="line">                    change = <span class="keyword">true</span>;</span><br><span class="line">                    swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (change == <span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序最好情况下也就是已经排好序时的时间复杂度为 O(N), 最坏情况发生在数组反向排序时，此时时间复杂度为O(N^2), 由于不占用额外空间，其空间复杂度为 O(1)。</p>
<p>冒泡排序作为排序中的启蒙算法比较简单，但是由于它 ？？？？</p>
<p>快排采取了 <strong>分治</strong> 的思想，每次选择一个元素作为枢轴 pivot，使其左边的值都小于 pivot，右边的值都大于 pivot，使用递归的方法对这两部分继续进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 只处理左边小于右边的情况</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> partition = partition(nums, left, right); </span><br><span class="line">        quickSort(nums, left, partition - <span class="number">1</span>);  </span><br><span class="line">        quickSort(nums, partition + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选定 pivot 并排序，返回一个 idx，idx 右边都大于 nums[idx]，左边都小于</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首节点设置为 pivot</span></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="comment">// 其实就是双指针</span></span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="comment">// 先 从右往左找一个 小于 pivot 的</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= pivot)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 从左往右找一个大于 pivot 的</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= pivot)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// swap</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终停下的 和 nums[left] swap</span></span><br><span class="line">    swap(nums, i, left);</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// new pivot</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  6 1 2 7 3 9 -&gt;  6 1 2 3 7 9  -&gt; 6 1 2 3 7 9</span></span><br><span class="line"><span class="comment">        i j             i j            j i  此时 j 遇到了 i，跳出循环,</span></span><br><span class="line"><span class="comment">  然后 swap(i, left), 得到 3 2 1 6 7 9， 可以发现 i 两边已经排好</span></span><br><span class="line"><span class="comment">                                i</span></span><br><span class="line"><span class="comment">  然后递归 quick(nums, 0, 2), 排 3 2 1  -&gt;   3  2 1                    -&gt; 3 2  1</span></span><br><span class="line"><span class="comment">                               i   j       i    j , j dont need move        i j  i 一路跑过来遇到 j，跳出循环，调换 3 和 1， 得到 1 2 3 ; </span></span><br><span class="line"><span class="comment">                                        i</span></span><br><span class="line"><span class="comment">递归 quick(nums, 0, 1); 以上简要介绍了快排的过程，省去了之中产生的递归。                                        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">值得注意的一点是，经常会看到 要 j 先走，然后 i 再走，经过一番推理，可能的一个原因是</span></span><br><span class="line"><span class="comment">如果 序列已经有序，比如 1 2 3 4, 如果让 i 先走，找一个大于 pivot 1的，那么它会一路走到 j 那里去</span></span><br><span class="line"><span class="comment">                    i     j</span></span><br><span class="line"><span class="comment">最终导致 1 和 4 互换位置，打乱顺序。               </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>快排的最优，平均，最坏时间复杂度为 O(nlog2n)，O(nlog2n)， O(n^2)，空间复杂度为 O （1）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/09/18/%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F/" data-id="cktpujk560000e79k6uoxfj2j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-选择类排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/17/%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2021-09-17T12:11:58.962Z" itemprop="datePublished">2021-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/17/%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">选择类排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>常用的排序算法可以分为：</p>
<ol>
<li><strong>选择类</strong>：简单选择排序，堆排序</li>
<li><strong>交换类</strong>：快速排序，冒泡排序</li>
<li><strong>插入类</strong>：简单插入排序，希尔排序</li>
</ol>
<h2 id="选择类"><a href="#选择类" class="headerlink" title="选择类"></a>选择类</h2><p>选择类的排序算法，核心就是为每个位置选取一定范围内最小（大）的值，随着各个位置最小值的确定，待选范围也不断缩小，只剩一个元素的时候就不用再比了。简单选择排序代码如下, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chooseSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">  	<span class="comment">// 从右往左排</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// initialize the idx and max number for each search</span></span><br><span class="line">        <span class="keyword">int</span> maxIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// choose the maximum number between [0 - i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;  <span class="comment">// 比较</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; max)&#123;   </span><br><span class="line">                max = nums[j];</span><br><span class="line">                maxIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, maxIdx); <span class="comment">// 交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择</strong>操作和<strong>交换</strong>操作次数在 0 - n-1 之间，而<strong>比较</strong>操作数随着范围的缩小从 n-1, n-2 一直到 1 等于 n*(n-1)/2, 时间复杂度 O(N^2). </p>
<p>另一个选择类排序方法为 堆排序，堆是一种完全二叉树，其父节点的值永远大于两个子节点。首先我们需要了解 数组 和 堆的转化形式，如下面代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">idx:   <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">val:  [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>]   -&gt;  left = <span class="number">2</span> * i + <span class="number">1</span>; right = <span class="number">2</span> * i + <span class="number">2</span>; i 为根节点 idx</span><br><span class="line">           <span class="number">5</span></span><br><span class="line">         /   \</span><br><span class="line">        <span class="number">2</span>     <span class="number">1</span></span><br><span class="line">       / \</span><br><span class="line">      <span class="number">6</span>   <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 第一步 - 堆化，让所有根节点变为最大, 要从下往上，一轮一轮把大的换上去, 从上往下的话上面大的可能换不到最底下去</span></span><br><span class="line"><span class="comment">// 先选最下面的根节点，由于堆是个满二叉树，可以推出来，根节点的 idx 范围是 0 ～ n/2 - 1;</span></span><br><span class="line"><span class="comment">// 那么就依次对 以值为 1，2，5 的树进行操作。1 节点的左右已经越界所以不用管，接着看 6，2，3 ，由于 6 大于 2和3，那么就把2，6位置交换。然后迭代的 hepify（2），发现左右子树也越界了。然后对 5 进行操作，道理一样，</span></span><br><span class="line">                   <span class="number">5</span>                <span class="number">6</span></span><br><span class="line">                 /   \             / \</span><br><span class="line">                <span class="number">6</span>     <span class="number">1</span>           <span class="number">5</span>   <span class="number">1</span></span><br><span class="line">               / \               / \</span><br><span class="line">              <span class="number">2</span>   <span class="number">3</span>             <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 这样我们就得到了一个最大堆，转化为 数组形式就是 [6,5,1,2,3]</span></span><br><span class="line"> <span class="comment">// 堆排序的核心就是两步,</span></span><br><span class="line"> <span class="comment">// 1. 把最大的值（也就是数组第一个值）和最后的元素交换，也就是从后往前，一个一个把最大的放上去</span></span><br><span class="line"> <span class="comment">// 2.然后对剩余的再进行堆化, 重复上一步</span></span><br><span class="line"> <span class="comment">// 代码如下</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 先建造一个二叉堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            heapify(nums, n, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时根节点已经最大，不断换到后面</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123; <span class="comment">// i 表示 堆化的范围，一直在缩小</span></span><br><span class="line">            swap(nums,<span class="number">0</span>, i);</span><br><span class="line">            heapify(nums, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">              </span><br><span class="line"><span class="comment">// 把以节点 i 为根节点的树，变成一个最大堆（最小堆），也就是根节点大于（小于）其两个子节点的值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> largest = i;    <span class="comment">// 假设 i 就以及是最大的点了</span></span><br><span class="line">      <span class="keyword">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 找到左儿子</span></span><br><span class="line">      <span class="keyword">int</span> r = <span class="number">2</span> * i + <span class="number">2</span>;  <span class="comment">// 找到右儿子</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找出 3 者里面最大的那个点</span></span><br><span class="line">      <span class="keyword">if</span>(l &lt; n &amp;&amp; nums[l] &gt; nums[largest])&#123; largest = l; &#125;</span><br><span class="line">      <span class="keyword">if</span>(r &lt; n &amp;&amp; nums[r] &gt; nums[largest])&#123; largest = r; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果不是 i 的话，就把 i 换走，并在对换上来的那个点继续进行二叉堆化</span></span><br><span class="line">      <span class="keyword">if</span>(largest != i)&#123;</span><br><span class="line">          swap(nums, largest, i);</span><br><span class="line">          heapify(nums, n, largest);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上面建好的堆为例子, n = 5</span></span><br><span class="line"><span class="comment">/* I:  i = 4, swap(0,4), 堆化列表前四个： </span></span><br><span class="line"><span class="comment">          [3,5,1,2,6], heapify(nums, 4, 0) [3,5,1,2,6]</span></span><br><span class="line"><span class="comment">               3           5</span></span><br><span class="line"><span class="comment">              / \         / \</span></span><br><span class="line"><span class="comment">             5   1       3   1   -&gt;  [5,3,1,2,6]</span></span><br><span class="line"><span class="comment">            /           /</span></span><br><span class="line"><span class="comment">           2           2</span></span><br><span class="line"><span class="comment">           </span></span><br><span class="line"><span class="comment"> II: i = 3, swap(0,3), -&gt; [2,3,1,5,6]   heapify(nums, 3, 0) </span></span><br><span class="line"><span class="comment">         2                3</span></span><br><span class="line"><span class="comment"> 		    / \     -&gt;      /   \    -&gt;  [3,1,2,5,6]</span></span><br><span class="line"><span class="comment">       3   1           2     1</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">III: i = 2, swap(0,2), -&gt; [2,1,3,5,6]   heapify(nums, 2, 0) </span></span><br><span class="line"><span class="comment">         2                2</span></span><br><span class="line"><span class="comment"> 		    /       -&gt;      /      -&gt;  [2,1,3,5,6]</span></span><br><span class="line"><span class="comment">       1               1             </span></span><br><span class="line"><span class="comment">IV: i = 1, swap(0,1), -&gt; [1,2,3,5,6]   heapify(nums, 1, 0) (里面什么也不用做了)</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">  *</span></span><br></pre></td></tr></table></figure>

<p>复杂度分析：O(n log n)</p>
<p>具体推算可以查看这篇文章 <a href="https://www.happycoders.eu/algorithms/heapsort/#Total_Time_Complexity_of_Heapsort" target="_blank" rel="noopener">https://www.happycoders.eu/algorithms/heapsort/#Total_Time_Complexity_of_Heapsort</a></p>
<p>堆排序的优点是时间稳定，最好最坏都是 <em>O(n log n)</em>，不像快排和归并排序，也不需要额外的内存空间。当我们需要找到前K大（小）的数时，我们并不需要保持其他元素顺序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/09/17/%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-id="cktogdxgs0000p29k931fhqwu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/16/mysql%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2021-09-16T13:30:01.942Z" itemprop="datePublished">2021-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/16/mysql%E7%B4%A2%E5%BC%95/">mysql索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数据库的数据大多被持久化在磁盘上，当我们查询时少不了要和磁盘发生 IO，由于时间开销很大（大约是内存IO的百万倍），我们需要在每一次查询时让访问磁盘的数量尽可能少。索引用来帮我们快速定位数据项，其数据结构也决定了 IO次数的多少，B+树作为为磁盘设计的一种平衡查找树，被广泛应用于索引数据结构。</p>
<p>如下图所示：每个节点都是一个磁盘块，其中包含数据项和指向其他磁盘块的指针。节点分为叶子节点和非叶子节点，非叶子节点只存储位置信息用来指引搜索方向，叶子节点才存储实际的数据项，也称为数据页，每个数据页通过一个双向链表相连（便于范围查询），。如果查找数据项10，那么首先会把磁盘块 1 加载进内存，发生1次IO，在内存中用二分查找确定8在10的前面，因此通过指针1再把磁盘块2 加载进内存（第二次IO），接着同理，根据指针2 的再将磁盘6加载进内存发生第三次 IO，同样也使用 2分查找，最终找到数据项结束查询，总计3次IO。</p>
<p>并且如果每个磁盘块存储的信息足够多，索引项很小的话，仅仅三层就可以存储百万级的数据项。这也是为什么只有叶子节点才存储数据项的原因（数据项会占用更多空间，导致每个磁盘块存储的节点信息少，接着导致层数增多，查询效率下降）。</p>
<img src="../images/B+树.png" alt="B+树" style="zoom:50%;" />

<p>B+树索引可以分为两种：</p>
<p><strong>聚簇索引</strong>：默认根据 <strong>主键</strong> 建立，主键只有一个，因此聚簇索引一个表也只有一个。没有的话InnoDB会选择一个唯一的非空索引代替，再没有的话就隐式定义一个主键来作为聚簇索引。聚簇索引的叶子节点就是数据节点。</p>
<p><strong>非聚簇索引</strong>：也称为辅助索引，叶子节点中存放的是主键的值，需要拿着这个值再去聚簇索引中查找记录，也就是进行两次 B+ 树查询。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/09/16/mysql%E7%B4%A2%E5%BC%95/" data-id="cktn0u36e0000e59k08bh6h31" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Normal Forms 数据库范式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/14/Normal%20Forms%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/" class="article-date">
  <time datetime="2021-09-14T11:05:33.343Z" itemprop="datePublished">2021-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/14/Normal%20Forms%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/">Normal Forms 数据库范式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a><strong>完全函数依赖</strong></h3><p>假设 X -&gt; Y, 并且 X 的任意一个真子集都推不出来 Y，那么就说 Y 完全依赖于 X。也就是说，要想推出 Y， X 中的属性缺一不可。</p>
<h3 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h3><p>比完全函数依赖稍弱，X 的真子集中存在 X‘ 可以推出 Y。</p>
<h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><p>X -&gt; Y, Y -&gt; Z, 就说 Z 传递依赖于 X</p>
<h2 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h2><p>Membership Table</p>
<table>
<thead>
<tr>
<th>student</th>
<th>email</th>
<th>society</th>
<th>department</th>
<th>faculty</th>
</tr>
</thead>
<tbody><tr>
<td>bb16801</td>
<td>bilbo@…</td>
<td>Cheese</td>
<td>modern language</td>
<td>arts</td>
</tr>
<tr>
<td>bb16801</td>
<td>bilbo@…</td>
<td>Hoverboard</td>
<td>civil engineering</td>
<td>engineer</td>
</tr>
<tr>
<td>mm16280</td>
<td>mickey@…</td>
<td>Hoverboard</td>
<td>mordern language</td>
<td>arts</td>
</tr>
</tbody></table>
<p>department 和 faculty 可以直接被 studentId 推出来，这部分就属于部分函数依赖，解决：把部分依赖于主键的非主属性，移动到另一张新表上，和他们部分依赖的主键一起。这样就实现了 1NF -&gt; 2NF 的转变。</p>
<h2 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h2><table>
<thead>
<tr>
<th>student</th>
<th>email</th>
<th>society</th>
</tr>
</thead>
<tbody><tr>
<td>bb16801</td>
<td>bilbo@…</td>
<td>Cheese</td>
</tr>
<tr>
<td>bb16801</td>
<td>bilbo@…</td>
<td>Hoverboard</td>
</tr>
<tr>
<td>mm16280</td>
<td>mickey@…</td>
<td>Hoverboard</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>student</th>
<th>department</th>
<th>faculty</th>
</tr>
</thead>
<tbody><tr>
<td>bb16801</td>
<td>modern language</td>
<td>arts</td>
</tr>
<tr>
<td>bb16801</td>
<td>civil engineering</td>
<td>engineer</td>
</tr>
<tr>
<td>mm16280</td>
<td>modern language</td>
<td>arts</td>
</tr>
</tbody></table>
<p>分析此时的第二张表格，学生可以推出他所属的department，而department 又和 faculty 学部有关系，也就是 student -&gt; department, department -&gt; faculty. 那么 faculty 传递依赖于 student. 为了消除传递函数依赖，我们再把 faculty 分离出去，得到下面的两张表，也就完成了 2NF -&gt; 3 NF 的转变。</p>
<h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><table>
<thead>
<tr>
<th>student</th>
<th>department</th>
</tr>
</thead>
<tbody><tr>
<td>bb16801</td>
<td>modern language</td>
</tr>
<tr>
<td>bb16801</td>
<td>civil engineering</td>
</tr>
<tr>
<td>mm16280</td>
<td>modern language</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>department</th>
<th>faculty</th>
</tr>
</thead>
<tbody><tr>
<td>modern language</td>
<td>arts</td>
</tr>
<tr>
<td>civil engineering</td>
<td>engineering</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/09/14/Normal%20Forms%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/" data-id="cktktw9y800006p9k8hu45dvx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-StringBuilder 原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/14/StringBuilder%20%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2021-09-14T06:11:57.332Z" itemprop="datePublished">2021-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/14/StringBuilder%20%E5%8E%9F%E7%90%86/">StringBuilder 原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 leetcode 上做题时，经常用到 StringBuilder 以及它的append（）和deleteCharAt（）方法，不禁好奇他内部到底是啥样的。查看后发现，StringBuilder 继承于 AbstractStringBuilder 类，并且它的大部分方法都调用 父类的方法，并没有太多自己的内容。</p>
<p>AbstractStringBuilder 的内部其实就是一个 char[] 和记录 char 长度的 count 变量。当我们调用 append（）时，大致分为 4 步。</p>
<ol>
<li><p>会查看 str 是否为 null，如果是的话会在 char[] 的末尾增加，null 这四个字符;</p>
</li>
<li><p>调用 ensureCapacityInternal(count + len); 并传入所需要的长度（count + str.length()）；</p>
</li>
<li><p>调用 str对象的 getChars() 方法，该方法调用 System.arraycopy() 将 string 的底层 char[] 拷贝到 StringBuilder 的 char[] value 中。</p>
<p>本质上，将 String，StringBuilder, StringBuffer, AbstactStringBuilder 底层都用到了 System.arraycopy() 这个 native方法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len); <span class="comment">// 传入最大长度 </span></span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);  <span class="comment">// value 就是char[]数组，count是char used的长度</span></span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;  <span class="comment">// 分配新空间</span></span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));  <span class="comment">// 内部也用到了 System.arraycopy()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 把该 str 的 chars 拷贝到目的地，也就是传入的 stringbuilder 底层 char[] value， value 是 str 对象底层的 char[]</span></span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/09/14/StringBuilder%20%E5%8E%9F%E7%90%86/" data-id="cktju4oex0000x69kahxl5d6e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-缓存的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/12/%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2021-08-12T01:21:26.074Z" itemprop="datePublished">2021-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/12/%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/">缓存的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="缓存不一致"><a href="#缓存不一致" class="headerlink" title="缓存不一致"></a><strong>缓存不一致</strong></h1><p>redis 用作缓存时，可能会产生和数据库数据不一致的问题。缓存的一致性根据缓存是否命中分为两方面：当缓存中有数据时，需要和数据库中保持一致；当没有数据时，要保证数据库中存在最新数据。</p>
<p>对读写缓存来说，这个问题比较好解决，使用 <strong>同步直写</strong> 策略，结合事务，保证更新操作的原子性，如果没有更新成功则进行重试。</p>
<p>对于只读缓存，当业务需要 <strong>更新或者删除</strong> 一个值时，要做两件事，一是删除缓存中的值，二是更新数据库的值。这两件事的先后顺序并不限制。增，查。</p>
<p>在并发的情况下，如果业务 2 在 业务1删完缓存数据后，更新数据库前查询该数据，业务 2 发现缓存中没有，那就去数据库里找，取出这个还没更新的旧数据，又把它写回了缓存。这样一来，业务 2 拿到了旧数据还把缓存的值给整回来了。This is a problem。可以采用 <strong>延迟双删</strong> 的方法，让业务 1 睡眠一段时间后，再进行一次缓存删除。</p>
<p>那么，如果 业务1 先改数据库，再删除缓存呢，也不行，这样在业务1没删除缓存之前，业务 2 还是会拿到旧数据。在并发请求不多时，这种影响较小。但是如果业务 1 删除失败，那缓存中就一直是旧数据。对于这种更新缓存或者数据库失败的情况，可以采用 <strong>重试机制</strong>，把需要更新的值写到消息队列里面，如果失败就重试。</p>
<p>总的来看，先更新数据库再更新缓存会好一点。因为延迟双删的时间不好确定（读取数据库和写缓存的时间可能不好估算），并且有额外开销。此外，先删除缓存，会造成缓存缺失而访问数据库，带来一些压力。</p>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>指大量的请求在缓存中无法命中，大量的到达数据库，数据库压力激增。一般来说一个 redis instace 可以支持数万级别请求，单个数据库可能只支持数千，一旦雪崩，数据库可能承受 十倍的请求压力。</p>
<h4 id="原因-1：-大量-key-同时过期"><a href="#原因-1：-大量-key-同时过期" class="headerlink" title="原因 1： 大量 key 同时过期"></a>原因 1： 大量 key 同时过期</h4><p>预防：用 EXPIRE 命令给每个数据增加一个较小的随机数</p>
<p>处理：服务降级，对于非核心数据，从缓存中返回预设值，空值或者错误信息；对于核心数据仍允许。</p>
<h4 id="原因-2：Redis-宕机"><a href="#原因-2：Redis-宕机" class="headerlink" title="原因 2：Redis 宕机"></a>原因 2：Redis 宕机</h4><p>预防：主从节点构造高可用集群</p>
<p>处理：服务熔断（暂停缓存使用，保护数据库），请求限流</p>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>针对某个<strong>热点数据</strong>的请求，无法在缓存中进行处理，全部发送到后端数据库。</p>
<h4 id="原因：热点数据失效"><a href="#原因：热点数据失效" class="headerlink" title="原因：热点数据失效"></a>原因：热点数据失效</h4><p>处理：对于热点数据不设置 Expire </p>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>要访问的数据不在缓存中，也不再数据库中，导致数据库大量读请求，占用资源。</p>
<h4 id="原因：业务层误删除，恶意攻击"><a href="#原因：业务层误删除，恶意攻击" class="headerlink" title="原因：业务层误删除，恶意攻击"></a>原因：业务层误删除，恶意攻击</h4><h4 id="处理：前端检测；缓存空值，缺省值；-布隆过滤器"><a href="#处理：前端检测；缓存空值，缺省值；-布隆过滤器" class="headerlink" title="处理：前端检测；缓存空值，缺省值； 布隆过滤器"></a>处理：前端检测；缓存空值，缺省值； 布隆过滤器</h4><p>布隆过滤器可以<strong>快速判断数据是否存在</strong>，由 N 个哈希函数，和一个初值为 0 的 bit 数组组成。</p>
<p>标记过程：</p>
<p>首先，用 N 个哈希函数对数据进行计算，得到 N 个哈希值。然后，把这 N 个哈希值对 bit 数组长度取模，set 数组中对应位置为 1。</p>
<p>查找：还是计算 N 个哈希值，看 bit 数组对应位置是否<strong>全部为 1</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/08/12/%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="cks8a3gsm0000gt9k4yxq5rrp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/08/%E7%BC%93%E5%AD%98/" class="article-date">
  <time datetime="2021-08-08T13:53:16.578Z" itemprop="datePublished">2021-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/08/%E7%BC%93%E5%AD%98/">缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>redis 自带数据淘汰策略和高速读写的功能，可以被用于实现缓存。redis 不同于操作系统的 LLC 和 page cache，应用想使用的话需要在程序中加入缓存读写代码，这种缓存类型也被称为 <strong>旁路缓存</strong>。</p>
<p>redis 缓存可以被分为两种，<strong>只读缓存</strong> 和 <strong>读写缓存</strong>。</p>
<p>只读缓存可以只负责读取数据，所有的数据写请求会直接发往后端的数据库。对于删改操作，应用需要先删除 redis 已有的数据，下次再读这些数据时，会发生缓存缺失，此时应用把这些数据再从数据库存储到 redis 中。只读缓存的好处是所有数据都在数据库中，不会有丢失的风险。</p>
<p>对于读写缓存，读写删改都在缓存中完成，这样虽然更快，但是数据有丢失的风险，因此需要对数据进行写回操作。写回分为<strong>同步写直写</strong>和<strong>异步写回</strong>。同步直在写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据<br>库都写完，才给客户端返回。异步写回中所有写请求都先在缓存中处理，等这些增改的数据 <strong>要被从缓存中淘汰出来时</strong>，缓存将它们写回后端数据库。二者的选择主要看应用场景中的写操作的数量，响应速度的要求。</p>
<h2 id="数据淘汰"><a href="#数据淘汰" class="headerlink" title="数据淘汰"></a>数据淘汰</h2><p>数据的淘汰策略有两大类，<strong>对设置了过期时间的数据 volatile</strong>中进行淘汰，在<strong>所有数据中 allkeys</strong>进行淘汰；这两大类中分别存在 LRU，LFU，RANDOM算法，第一种还有一个根据 <strong>ttl</strong> 时间，也就是过期时间的先后来淘汰的策略；总的来说有七种加一种不进行淘汰（缓存写满就报错）。</p>
<p>Redis 的 LRU 算法做了简化，Redis 会记录每个数据的<strong>最近一次访问的时间戳</strong> (由键值对数据结构 RedisObject 中的 lru 字段记录)，redis 维护一个大小为 N （set maxmemory-samples ） 的候选集，在需要淘汰时就选 LRU 值最小的淘汰，集合中加入的新元素的 LRU 值要小于集合里面所有的。</p>
<p>如果场景中有冷热数据的区分，可以优先选择 allkeys-lru 策略，没有可以选择 allkeys-random；如果业务中有有始终会被频繁访问的数据，可以把这部分数据不设置过期时间，用 volatile-lru 对其他数据进行淘汰。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/08/08/%E7%BC%93%E5%AD%98/" data-id="cks3b1xmv0000ts9kdbcmbtgv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/05/DAG%20%E6%A3%80%E6%B5%8B/">DAG 检测</a>
          </li>
        
          <li>
            <a href="/2021/09/30/HSBC%20job%20simulation%20test/">HSBC job simulation test</a>
          </li>
        
          <li>
            <a href="/2021/09/25/DISTINCT%20&%20GROUP%20BY/">DISTINCT &amp; GROUP BY</a>
          </li>
        
          <li>
            <a href="/2021/09/18/%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F/">交换类排序</a>
          </li>
        
          <li>
            <a href="/2021/09/17/%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">选择类排序算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Zhang Penghe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>